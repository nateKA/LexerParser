<!--

This is a sample xml document that acts as an instruction on how to format and use functionality
of the Lexer/Parser that generate from xmls.

The xml you create should follow the same schema, or your parser will not compile correctly

Many elements contain attributes that are 'reserveWords' for compiling the lexer/parser. reserveWords fall into two categories
'compileTime' - The reserveWord is used to compile the Lexer/Parser and will not appear in Tokens
'runTime' - The reserveWord is reserved for the Lexer/Parser to add to the tokens. These are bits of information
        that Tokens almost require in order to be useful

Any attribute that is not a reserveWord will be passed on to the Token
        
Here is a list of reserveWords

    Token reserveWords
        boundaries - compileTime - tells Lexer if it should use word boundaries for all Child Regex elements
        ignoreCase - compileTime - tells the Lexer if it should ignore case when matching regex patterns
        addSlashes - compileTime - tells the Lexer if it should add escape characters to regex strings
        XMLtag - compileTime - Used for compiling purposes
        annotationText() - runTime - The text that constituted the Token
        startOffset() - runTime - the first character's index in the originating text
        endOffset() - runTime - the last character's index in the originating text

    Regex reserveWords
        regex - compileTime - Some regex Patterns violate xml format. This attribute allows for a backup plan
        XMLtag - compileTime - Used for compiling purposes

    Pattern reserveWords
        Sequence - compileTime - Determines order Pattern is parsed in
        XMLtag - compileTime - Used for compiling purposes

    Rule and Rubric reserveWords
        min - compileTime - A rule must be matched this number of times or more, Setting this to 0 means it is optional
        max - compileTime - A rule cannot be matched more than this number of times
        XMLtag - compileTime - Used for compiling purposes

-->
<XMLBody>
    <tokens>

        <!-- attributes in the <token> tag will be added to a HashMap<String,String> in the Token generated by the Lexer
        i.e. Tokens generated by the block will inherit the attributes granted they are not reserveWords-->
        <token type="word" >
            <regex>\w+</regex>
        </token>
        <token type="punct" >
            <regex>\.</regex>
            <regex>,</regex>
            <regex>'</regex>
            <regex type="hyphen">-</regex>
            <regex>:</regex>
            <regex>\[</regex>
            <regex>]</regex>
            <regex>;</regex>

            <!-- this is an alternative to using the innerXML. Since the '<' is a reserved character by XML
            this is a good use for the 'regex' attribute -->
            <regex sub_type="lessThan" regex="<"/>
        </token>

        <!-- boundaries is a boolean that controls the word boundary in regex i.e. regex = '\b(\d+)\b' -->
        <!--  in other words, "a7fee78" and "73a" are not numbers -->
        <token type="number" boundaries="true" >
            <regex sub_type="decimal">\d+</regex>
            <regex sub_type="binary">0b\d{8}</regex>
            <regex sub_type="hexadecimal">0x\d{1,8}</regex>
        </token>

        <token type="reference">

            <!-- setting an attribute to the group() function call will set that attribute equal to the
            the value of the requested capture group -->
            <regex value="group(1)">No\.\s+(\d+)</regex>
            <regex value="group(1)">\[(\d+)]</regex>
        </token>

        <!-- ignoreCase attribute controls if the regex should ignore case -->
        <token type="month" boundaries="true" ignoreCase="true">

            <!-- Attributes in the <regex> tag are also added to the Token's HashMap. If a <regex> tag has an
            attribute with the same name as the enclosing <token> tag, the <regex> attribute will overwrite -->
                <regex month="December">dec|december</regex>
                <regex month="January">jan|january</regex>
                <regex month="February">feb|february</regex>
                <regex month="March">mar|march</regex>
                <regex month="April">apr|april</regex>
                <regex month="May">may</regex>
                <regex month="June">jun|june</regex>
                <regex month="July">jul|july</regex>
                <regex month="August">aug|august</regex>
                <regex month="September">sept|sep|september</regex>
                <regex month="October">oct|october</regex>
                <regex month="November">nov|november</regex>
        </token>


        <!-- this token has the potential to find the same test as the month token. When a collision like this
            occurs, the newest token will keep all of its attributes and inherit the attributes from the old token
            if the new one does not already own attributes of the same name -->
        <token form="capitalized" boundaries="true">
            <regex>[A-Z][a-zA-Z]+</regex>
        </token>

    </tokens>

    <patterns>
        <!-- the sequence attribute determines the order this pattern is parsed in.
        You can also order them based on their placement in the xml doc -->
        <pattern sequence="0" type="date">
            <rule>
                <rubric>
                    <check>type=month</check>
                </rubric>
                <rubric>
                    <!-- a rubric element containing multiple checks will logically AND 
                    each check -->
                    <check>type=number</check>
                    <check>sub_type=decimal</check>
                </rubric>
                <rubric>
                    <check>annotationText()=,</check>
                </rubric>
                <rubric>
                    <check>type=number</check>
                    <check>sub_type=decimal</check>
                </rubric>
            </rule>
        </pattern>
        <pattern type="word">
            <rule>
                <rubric>
                    <check>type=word</check>
                </rubric>
                <rubric>
                    <check>type=hyphen</check>
                </rubric>
                <rubric>
                    <check>type=word</check>
                </rubric>
            </rule>
        </pattern>
        
        <pattern type="title">
            <rule>
                <rubric min="2" max="10">
                    <check>form=capitalized</check>
                    <check>type=word|month</check>
                </rubric>
            </rule>
        </pattern>
    </patterns>
</XMLBody>
